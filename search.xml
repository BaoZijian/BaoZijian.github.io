<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[七牛直播云播放鉴权-时间戳防盗链]]></title>
      <url>%2Fshijianchuo.html</url>
      <content type="text"><![CDATA[基于时间戳防盗链的功能其实每家的 CDN 都是支持的。主要是通过使用约定的加密字符串来对具有访问有效期的资源链接进行一些加密计算的到一个 sign 值，然后访问外链里面带上这个sign和截止时间戳去访问CDN的节点，CDN的节点会用同样的算法来计算访问链接是否合法，如果不合法则返回403 Forbidden，否则返回所要访问的资源。 算法说明基于时间戳的防盗链是通过对时间有关的字符串进行签名，将时间，签名通过一定的方式传递给CDN服务器作为判定依据，CDN 边缘节点依据约定的算法判断来访的URL是否有访问权限。如果通过，执行下一步；如果不通过，响应 HTTP 状态码 403。⭐️ 七牛直播云支持两种时间戳防盗链：①tsStartMD5指定起始时间戳播放鉴权。token的生成算法是md5，有效时间从URL的时间戳(十六进制)开始到”range”秒后。②tsExpireMD5指定过期时间戳播放鉴权。token的生成算法是md5, 有效时间从现在开始到URL中的时间戳(十六进制)为止。 签名参数 参数 描述 T(2种) ①起始时间，把Unix以秒为单位的时间戳，用16进制的小写字母形式表示，提交 CDN 厂商固定的 range 过期时间，比如 5 分钟，那么以当前时间 T 签算，固定在 T+300s 后过期 ②URL过期的时间，把Unix以秒为单位的时间戳，用16进制的小写字母形式表示。比如 2017年 2月22日 10时07分36秒 CST 对应的时间戳是 1487729256 ，表示为16进制就是 58acf268。 key 和 CDN 约定好的加密字符串 path 访问资源外链的PATH部分，比如如果访问的外链是 http://pili-live-hls.baozijian.cc/tron/baozijian.m3u8 那么其中 PATH 部分就是 /tron/baozijian.m3u8 签名算法待签名的原始字符串 s=key+path+T签名方式 sign=md5(s).to_lower() ，其中 to_lower() 表示生成的md5字符串用小写字母表示 签名参数传递方式例如播放地址是：http://pili-live-hls.baozijian.cc/tron/baozijian.m3u8最终形成的播放地址是：http://pili-live-hls.baozijian.cc/tron/baozijian.m3u8&amp;sign=xxxx&amp;t=xxxx 算法参考实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qiniulab.cdn;import java.io.UnsupportedEncodingException;import java.net.MalformedURLException;import java.net.URL;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import org.apache.commons.codec.binary.Hex;public class CdnAntiLeech &#123; /** * 生成资源基于CDN时间戳防盗链的访问外链 * * @param 资源原始外链 * @param 结果资源的有效期，单位秒 * @throws MalformedURLException * @throws UnsupportedEncodingException * @throws NoSuchAlgorithmException */ public static String getAntiLeechAccessUrlBasedOnTimestamp(String url, String encryptKey, int durationInSeconds) throws MalformedURLException, UnsupportedEncodingException, NoSuchAlgorithmException &#123; URL urlObj = new URL(url); String path = urlObj.getPath(); long timestampNow = System.currentTimeMillis() / 1000 + durationInSeconds; String expireHex = Long.toHexString(timestampNow); String toSignStr = String.format("%s%s%s", encryptKey, path, expireHex); String signedStr = md5ToLower(toSignStr); String signedUrl = null; if (urlObj.getQuery() != null) &#123; signedUrl = String.format("%s&amp;sign=%s&amp;t=%s", url, signedStr, expireHex); &#125; else &#123; signedUrl = String.format("%s?sign=%s&amp;t=%s", url, signedStr, expireHex); &#125; return signedUrl; &#125; private static String md5ToLower(String src) throws UnsupportedEncodingException, NoSuchAlgorithmException &#123; MessageDigest digest = MessageDigest.getInstance("MD5"); digest.update(src.getBytes("utf-8")); byte[] md5Bytes = digest.digest(); return Hex.encodeHexString(md5Bytes); &#125;&#125; 使用方式123456789101112131415161718192021// cdn 配置的基于时间戳防盗链的加密字符串，cdn 配置完成后会得到String encryptKey = "";// 待加密链接String fileKey = "xxxx.pdf";String encodedFileKey;try &#123; // 考虑到文件名称会有中文，所以需要做urlencode encodedFileKey = URLEncoder.encode(fileKey, "utf-8"); String urlToSign = String.format("http://img.abc.com/%s", encodedFileKey); // 有效期 int duration = 3600; String signedUrl = CdnAntiLeech.getAntiLeechAccessUrlBasedOnTimestamp(urlToSign, encryptKey, duration); System.out.println(signedUrl);&#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace();&#125; catch (MalformedURLException e) &#123; e.printStackTrace();&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛的第一个圣诞节]]></title>
      <url>%2F%E4%B8%83%E7%89%9B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9C%A3%E8%AF%9E%E8%8A%82.html</url>
      <content type="text"><![CDATA[牛棚过圣诞节今天周五，忙碌的一天，但是公司氛围还是足足哒 晒几张图😍 公司 HR 给我们发的秘密报备看起来挺正常的这个指的是？oppo 充电手机？额好吧，啥也不说了，公司 HR 姐姐，你变了 还请了美女鼓励师 再看看人家的鼓励师，啥也不说了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo部署至七牛之一键操作]]></title>
      <url>%2Fhexo%E9%83%A8%E7%BD%B2%E8%87%B3%E4%B8%83%E7%89%9B%E4%B9%8B%E4%B8%80%E9%94%AE%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[吐槽： 每次部署都要敲那么多命令，真的是心都累了 七牛所有资源默认走 CDN 加速，静态博客又想缓存，部署过后又不想缓存，真是烦 不行，逼格还是不够高 开始动手先看效果 前提已经能够成功部署上传至七牛的操作，参考平台部署hexo之『七牛云存储』 脚本完成功能如下 本地生成静态页面 同步本地静态文件至七牛 刷新七牛 CDN 缓存 脚本如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env bash# 本地部署hexo cleanhexo gecho ""echo "本地页面生成成功!"echo "" # qshell 同步静态文件到七牛qshell qupload /Users/Baozi/Documents/hexo/newblog/hexoup_conf.txtecho ""echo "上传结束，正在刷新缓存..."echo ""echo ""# 刷新 CDN 缓存ak="①这里填写七牛的AccessKey"token=$(echo "/v2/tune/refresh" |openssl dgst -binary -hmac "②这里填写你的SecretKey" -sha1 |base64 |tr "+/" "-_")result=$(curl -X POST -H "Authorization: QBox $ak:$token" http://fusion.qiniuapi.com/v2/tune/refresh -d '&#123;"dirs":["③这里填写你的主页"]&#125;' -H 'Content-Type: application/json')code=$(echo $result | awk -F ',' '&#123;print $1&#125;' | awk -F ':' '&#123;print $2&#125;')urlSurplusDay=$(echo $result | awk -F 'urlSurplusDay' '&#123;print $2&#125;' | awk -F '":' '&#123;print $2&#125;' | awk -F ',' '&#123;print $1&#125;')if [[ $code = 200 ]]; then echo "----------------------------------" echo "刷新成功!" echo "本日剩余刷新次数为$urlSurplusDay" echo "----------------------------------" echo "欢迎访问:" echo "④这里填写你的主页地址" echo "" echo "⑤这里填写你的主页地址" | pbcopyelif [[ $code = 400031 ]]; then echo "请求中存在无效的 url，请确保 url 格式正确"elif [[ $code = 400032 ]]; then echo "请求中存在无效的域名，请确保域名格式正确"elif [[ $code = 400034 ]]; then echo "请求次数超出当日刷新限额,请联系七牛技术支持"elif [[ $code = 400036 ]]; then echo "无效的请求 id"elif [[ $code = 400037 ]]; then echo "url 正在刷新中"elif [[ $code = 500000 ]]; then echo "服务端内部错误，请联系技术支持"else echo "未知错误，你脚本有问题！"fi qshell的hexoup_conf.txt文件如下123456789101112&#123; "src_dir" : "这里填写public在本地的绝对路径", "access_key" : "这里填写AK", "secret_key" : "这里填写SK", "bucket" : "这里填写七牛存储空间名，刚才我新建的叫做myblog", "zone" : "nb", "ignore_dir" : false, "overwrite" : true, "check_exists" : false, "rescan_local" : true, "check_hash" : true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于七牛各种demo汇总]]></title>
      <url>%2F%E5%85%B3%E4%BA%8E%E4%B8%83%E7%89%9B%E5%90%84%E7%A7%8Ddemo%E6%B1%87%E6%80%BB.html</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[平台部署hexo之『VPS服务器』]]></title>
      <url>%2F%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2hexo%E4%B9%8B%E3%80%8EVPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8F.html</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[平台部署hexo之『七牛云存储』]]></title>
      <url>%2F%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2hexo%E4%B9%8B%E3%80%8E%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E3%80%8F.html</url>
      <content type="text"><![CDATA[前言按照道理，我先来扯一堆没用的东西 最近准备开始学习写博客，写博客首先就是考虑博客的托管，是在什么地方写好呢？尝试了很多，比如 CSDN、博客园、简书等等，再早一些还玩过 wordpress，但是总觉得不够好用，也不够美观(可能是我比较挑剔，说白了就是事儿多)。后来接触到了 hexo，真心简洁美观，一眼看到就定心里去了，于是乎着手搞了起来… 最开始跟着官网教程，读了半天也没看懂到底是怎么一个逻辑，后来 google 查了好久才知道原来是本地生成静态页面，然后 push 到 github，了解这个，就跟着教程和 google 来的大神一步步做，很快也就部署上去了，部署置 github 的过程我就不说了，直接贴其他博主的外链供参考吧，都是溜溜的 笑话人生 Ehlxr’s Blog 简述既然是本地生成的静态页面，可以用 hexo d -g 部署到 github 上面，那当然可以部署到其他的云平台上了，只不过 hexo 不支持直接部署非 git 平台，那么解决方式我这边有两种： 本地生成静态页面，push 到七牛云存储 在 VPS 上搭建 git 服务器，然后将部署位置指向 vps 的 git 服务器上 为啥选择七牛？ 七牛在功能特性上，一直在引领云存储的潮流。我们试图改变云存储，让她更加人性化，更加好用。 特有的上传加速能力。其他云存储通常只加速下载（CDN）。有的号称支持上传加速，其实也就只是做了上传的代理节点。但是七牛是全球首家采用多IDC架构的分布式存储。数据就近上传到某个IDC即落地，真正加速到极致。 特有的断点续上传功能。不再需要网络不行时在那一遍遍从头再来。无论网络多糟糕（尤其是3G/2G移动网络）、无论文件多大，我们都能够保证让你的数据到达服务器。这个在国内仍然没有其他云存储能够做到。 CDN整合。七牛目前整合了包括蓝汛、网宿在内的多家 CDN，总节点数已经超过 1000 个IDC，这让自建 CDN 望尘莫及。我们不重新发明轮子。但我们要让 CDN 从高端走向平民。为什么只能大公司才能享受 CDN 带来的好处？有了七牛，你就是个博客主也可以享受高品质的快感。七牛还帮你做了智能的 CDN 品质监测。万一某家 CDN 出现局部节点问题时，七牛还能够自动帮你把该区域切换到另一家 CDN，整个过程透明，让你省时省心。 独特的镜像存储，体验七牛云存储只需一键。 流媒体（音视频处理）支持。这个目前国内云存储也是首家。悄悄告诉你，最近音视频支持还会重大更新哦。 数据处理功能的级联（也就是管道）。图片先缩略再打水印，是管道功能的典型案例。 大文件支持。七牛云存储单文件最大支持到1TB。更多特性介绍，请访问 http://www.qiniu.com/, http://docs.qiniu.com/ 。也可以到 https://portal.qiniu.com/ 直接来体验。 七牛还提供免费的 10G 存储和 10G 免费下载流量，每个月都有哦。 七牛还是强大的服务支持团队，电话或者工单直接处理问题。 配置过程静态文件生成位置首先进入到我们的博客文件夹，我的是在~/Document/hexo/newblog12345cd ~/Document/hexo/newbloghexo cleanhexo d 执行完成之后，会在当前目录下发现一个public/的文件夹，这个文件夹里都是.html的静态博客页面 如何上传到七牛首先注册七牛账号七牛传送门,点我直接进入七牛注册页面 按照填写后，需要登录自己的邮箱进行激活，如果邮箱内找不到邮件，可以去垃圾箱看看，如果垃圾箱也没有，一般可能是邮件发送你的邮箱失败，被拒绝或者其他原因，此时可以拨打 400-808-9176 激活，或者提交一个工单来激活。 实名认证⭐️ 必须要实名认证，否则只有 1G 免费额度，上传文件类型也会有限制，否则报错 “limited mimeType” 创建对象存储空间存储空间在七牛，称为bucket，我们需要先新建一个bucket 这里创建好之后，东西就可以往这个地方进行存储了。 测试一下上传点击更多操作–&gt;内容管理 点击上传文件随便选择本地的一个小于500M的文件来上传至七牛 上传一个文件到七牛 这个时候在七牛的存储空间就看到了这个文件，点击复制外链，然后复制贴进浏览器访问 如果访问成功，说明你可以正常使用七牛的云存储服务了。 用命令行实现批量上传那么前端这样一个一个传到七牛，或者批量全选，把public/文件夹的所有内容在页面上批量选中上传，是不是一点都不酷，写个博客还要手动到这里上传，不愿意这么做，那么还是有什么方式上传到七牛呢？ sdk上传 工具上传这里，我们推荐使用工具上传，第一节省了 sdk 开发时间(想搞的话也是墙裂推荐的)，第二用的命令行工具上传，速度快而且功能强大，七牛提供各种上传工具，本人比较偏向 qshell 工具，这里推荐 qshell qshell工具下载 mac版本 ubuntu&amp;centos版本 qshell工具配置先本地下载 qshell1wget 'https://upload.bz1.me/qshell' 修改一下工具权限1chmod 755 qshell 放到环境变量中1mv qshell /usr/local/bin/ 新建一个terminal窗口1qshell -h 如果看到如下界面，证明可用了 登陆 qshell这里的 AK SK 在七牛控制台的个人面板中获取1qshell account &lt;AK&gt; &lt;SK&gt; AK SK 位置截图如下 然后查看下登陆1qshell account 正确的就是个效果 qshell部署你的博客进入七牛空间然后进入你的 public/的文件夹，并新建一个 qshell 上传批量上传的配置文件(用来告诉 qshell，上传哪些文件，有哪些上传策略)123cd ~/Document/hexo/newblogtouch upload.txt 编辑upload.txt文件，按照我的配置来就可以基本事件覆盖重写等规则，详细的可以参考，qupload1vim upload.txt 123456789101112&#123; "src_dir" : "这里填写public在本地的绝对路径", "access_key" : "这里填写AK", "secret_key" : "这里填写SK", "bucket" : "这里填写七牛存储空间名，刚才我新建的叫做myblog", "zone" : "nb", "ignore_dir" : false, "overwrite" : true, "check_exists" : false, "rescan_local" : true, "check_hash" : true&#125; 编辑好之后保存，然后本地先生成静态文件123hexo cleanhexo deploy 生成好之后，执行上传命令1qshell qupload upload.txt 看到这个样子，发现总共 n 个文件，成功了 n 个文件，失败 0 个，就 ok 了 如果报错”limited mimeType”,请先实名认证，文件类型上传有限制。 细节修改和测试然后我们需要到七牛修改一下默认首页显示，因为七牛空间允许存在无命名的空文件，一般我们都知道访问一个站点的时候，虽然输入网址是 https://www.bz1.me/，实际上访问的是 https://www.bz1.me/index.html开启之后，就可以用空间自带的测试域名对博客进行访问啦，域名在这里然后到浏览器中，直接将测试域名贴进去，访问看看 优化 一键部署并刷新 CDN 缓存 自定义域名，使用 cdn.bz1.me 访问 https 支持，使用 https://www.bz1.me 访问 阅读次数统计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于七牛推拉流地址]]></title>
      <url>%2F%E5%85%B3%E4%BA%8E%E4%B8%83%E7%89%9B%E6%8E%A8%E6%8B%89%E6%B5%81%E5%9C%B0%E5%9D%80.html</url>
      <content type="text"><![CDATA[publish-domain : pili-publish.baozijian.cc rtmp-pull-domain : pili-live-rtmp.baozijian.cc hls-pull-domain : pili-live-hls.baozijian.cc flv-pull-domain : pili-live-hdl.baozijian.cc hub : tron title : baozijian key : baozijian 关于七牛的推流地址静态鉴权推流地址举例1rtmp://pili-publish.baozijian.cc/tron/baozijian?key=baozijian 其他格式鉴权播放地址格式请参考：七牛直播推流鉴权 这个推流地址是有固定的组成格式，格式如下1rtmp://&lt;publish-domain&gt;/&lt;hub&gt;/&lt;tilte&gt;?key=&lt;key&gt; 关于七牛的拉流地址播放地址举例12345678# rtmp 播放地址：rtmp://pili-live-rtmp.baozijian.cc/tron/baozijian# hls 播放地址：http://pili-live-hls.baozijian.cc/tron/baozijian.m3u8# flv 播放地址：http://pili-live-hdl.baozijian.cc/tron/baozijian.flv 对应的播放地址的格式：12345678# rtmp 播放地址：rtmp://&lt;rtmp-pull-domain&gt;/&lt;hub&gt;/&lt;tilte&gt;# hls 播放地址：http://&lt;hls-pull-domain&gt;/&lt;hub&gt;/&lt;tilte&gt;.m3u8# flv 播放地址：http://&lt;flv-pull-domain&gt;/&lt;hub&gt;/&lt;title&gt;.flv]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛直播推流鉴权]]></title>
      <url>%2F%E4%B8%83%E7%89%9B%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E9%89%B4%E6%9D%83.html</url>
      <content type="text"><![CDATA[四种鉴权方式1. static 静态校验（弱鉴权）1rtmp://domain/hub/title?key=&#123;可以更改的key&#125; 可以针对某个流来设置这类鉴权 2. dynamic 动态校验（强鉴权）1rtmp://domain/hub/title?nonce=&#123;自定义某个时间戳&#125;&amp;token=&#123;publishToken&#125; 这种鉴权，推流地址只能用一次，如果使用过了一次后，需要重新签算，可以针对某个流来设置 3. expiry 时间戳鉴权1rtmp://domain/hub/title?expire=&#123;自定义某个时间戳&#125;&amp;token=&#123;publishToken&#125; 这种是在指定的时间戳内，可以推流。需要针对hub来设置此类鉴权，即hub内所有流都是expire鉴权。 4.none 鉴权1rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt; 这种鉴权方式称为无校验鉴权，不限时间也无校验 ⭐️注意：目前手机端推流 支持 static 和 dynamic 两种鉴权 概念 title: 流名，title 是 1-200 个字符，英文+数字组成，title 格式要求：^[a-zA-Z0-9_-]{4,100}$ ，title不能重复 publishKey：流密钥，1-200 个字符，英文+数字组成，publishKey 格式要求：^[a-zA-Z0-9_-]{4,100}$ ，可以重复 publishSecurity： 鉴权方式，如上四种，目前手机端推流，仅支持 static dynamic PublishSecurity 鉴权方式：即鉴权方式。决定了推流地址的有效性和合法性。是应用(Hub)的属性,可以在控制台应用属性中进行修改。推流时，使用rtmp://&lt;HubPublishDomain&gt;/&lt;StreamKey&gt;?&lt;鉴权方式中的publishKey或token&gt;这样带有鉴权参数的地址，可获得推流能力。包括四种鉴权方式，static 静态推流地址/expiry限时推流地址/dynamic动态推流地址/none无鉴权方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛控制台直播空间详解]]></title>
      <url>%2F%E4%B8%83%E7%89%9B%E7%9B%B4%E6%92%AD%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3.html</url>
      <content type="text"><![CDATA[直播空间截图和具体的设置方式细节在后面，首先先介绍一下七牛的推流地址 关于七牛 streamJson 注释七牛的 Android 和 ios 推流可以使用streamJson或者七牛推流地址(url)进行推流。 服务端 V1 版本的 sdk 同时支持生成 url 和 streamJson 服务端 V2 版本的 sdk 不支持生成 streamJson1234567891011121314151617181920212223242526&#123;"id": "z1.tron.baozijian", //流 id"createdAt": "2016-12-12T06:08:51.365Z", //创建时间"updatedAt": "2016-12-12T06:08:51.365Z", //更新时间"title": "baozijian", //流名称"hub": "tron", //直播空间名"disabled": true, //是否禁播流"publishKey": "baozijian", //流秘钥"publishSecurity": "static", //鉴权方式"hosts": &#123;"publish": &#123;"rtmp": "pili-publish.baozijian.cc" //rtmp 推流域名&#125;,"live": &#123;"hdl": "pili-live-hdl.baozijian.cc", //flv 播放域名"hls": "pili-live-hls.baozijian.cc", //hls 播放域名"http": "pili-live-hls.baozijian.cc", //hls 播放域名"rtmp": "pili-live-rtmp.baozijian.cc", //rtmp 播放域名"snapshot": "pili-live-snapshot.baozijian.cc" //实时截图域名&#125;,"playback": &#123;"hls": "10005x3.playback1.z1.pili.qiniucdn.com", //playback 回看域名"http": "10005x3.playback1.z1.pili.qiniucdn.com" //playback 回看域名&#125;&#125;&#125; 七牛直播空间名&amp;域名管理 hub：tron rtmp 推流域名：pili-publish.baozijian.cc rtmp 播放域名：pili-live-rtmp.baozijian.cc hls 播放域名：pili-live-hls.baozijian.cc ts 切片域名：pili-media.baozijian.cc flv 播放地址：pili-live-hdl.baozijian.cc 直播封面：pili-live-snapshot.baozijian.cc 七牛直播流管理&amp;推拉流地址&amp;禁播状态&amp;时间记录 hub：tron rtmp 推流地址：rtmp://pili-publish.baozijian.cc/tron/baozijian?key=baozijian rtmp 播放地址：rtmp://pili-live-rtmp.baozijian.cc/tron/baozijian hls 播放地址：http://pili-live-hls.baozijian.cc/tron/baozijian.m3u8 flv 播放地址：http://pili-live-hdl.baozijian.cc/tron/baozijian.flv 禁播状态：true 创建时间：2016-12-12 14:08:51 更新时间：2016-12-12 14:21:32 七牛直播空间设置七牛 portal.qiniu.com 控制台的直播空间设置中有如下属性可以设置： 直播空间名称：tron『这个就是 hub 名』 存储空间名称：直播内容会切片落存储到该空间，直播转存，或者手动请求 snapshot() 都会保存在该空间 存储过期时间：直播内容会在直播后指定的时间内被自动删除，如果希望永久存储，需要调用 saveas() 接口进行转存 直播封面：开启后，可以根据http://&lt;domain&gt;/&lt;hub&gt;/&lt;title&gt;.jpg，进行访问，会实时刷新 e.g. http://pili-live-snapshot.baozijian.cc/tron/baozijian.jpg 直播状态通知：当直播的状态有变化时，发送通知到指定的 URL 地址 直播中断超时：当一个流正在推的时候，status() 可以获取到流的状态为 connected,当pili持续 n 秒内没有收到推流端推送来的数据后，流会由 connected 变为 disconnected n 秒即为该 hub 的 timeout ，n 秒的值可以在此处设置。 直播鉴权：此处手动设置只有三种，实际有四种直播鉴权『static、dynamic、expire、none』详细参考 删除直播空间：删除直播空间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于七牛直播流状态]]></title>
      <url>%2F%E5%85%B3%E4%BA%8E%E4%B8%83%E7%89%9B%E7%9B%B4%E6%92%AD%E6%B5%81%E7%8A%B6%E6%80%81.html</url>
      <content type="text"><![CDATA[流状态共有两种： connected disconnected 回调： 流状态发生改变都会回调 http raw post data 发送到回调服务器 在直播空间设置中可以填写回调服务器地址 关于推流状态判断： 客户端可以发送 stopStreaming 给服务端，主动断开连接 如果因为网络或者其他原因，客户端未能发送断开请求 服务端有一个 status() 方法，查询流状态 如果在超时时间内还未能收到断开请求，服务端就会主动将 status 置为 disconnected 超时时间在直播空间设置中可以选择，默认 15s]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[qshell 批量删除操作]]></title>
      <url>%2F%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[qshell 删除指定时间前的文件12cat 1.txt | awk '&#123;print $4&#125;' | cut -c 1-10 &gt;2.txtpaste 2.txt 1.txt | awk '&#123;print $1" “$2&#125;' | awk '$1&lt;1472371200&#123;print $2&#125;' qshell 删除指定时间内的文件12cat myty-live.list.txt | awk '&#123;print $4&#125;' | cut -c 1-10 &gt;time1.txtpaste time1.txt myty-live.list.txt | awk '$1&gt;=1473650315 &amp;&amp; $1&lt;=1473650495&#123;print $3” “$2&#125;’ qshell 批量删除操作 qshell 下载地址&amp;文档(http://developer.qiniu.com/code/v6/tool/qshell.html) qshell account 登陆 qshell listbucket 列举出空间所有文件 根据自己的需求过滤出文件名(如果全部删除，则不需要过滤) qshell batchdelete 批量删除]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bash shell]采用表单/分片上传文件至七牛云]]></title>
      <url>%2Fshell-%E9%87%87%E7%94%A8%E8%A1%A8%E5%8D%95-%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3%E4%B8%83%E7%89%9B%E4%BA%91.html</url>
      <content type="text"><![CDATA[注意1：需要将 qshell 加入环境变量1mv qshell /usr/local/bin/qshell http://developer.qiniu.com/code/v6/tool/qshell.html 注意2：此脚本需要注册七牛云账号，获取 ak 和 sk，以及创建 bucket 用于存储快速入门：http://developer.qiniu.com/article/kodo/kodo-first/quickstart.html 需要配置的参数 ak sk bucket domain shell 脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env bashii=$1qshell account &lt;ak&gt; &lt;sk&gt;jj=$(ls -l | grep $ii | awk '&#123;print $5&#125;')if [[ $jj -lt '100000000' ]]; then echo "" echo "文件大小：$bb" echo "此文件小于100M，将采用表单上传" echo "" qshell fput &lt;bucket&gt; $ii $1 | tee -a test1111 xx=$(cat test1111 | grep "Put" | awk -F ')' '&#123;print $2&#125;') rm test1111 if [[ $xx = ' success!' ]]; then echo "" echo "访问链接：" echo "http://&lt;domain&gt;/$ii" echo "" else echo "Fail, please try again!" fielif [[ $jj -ge '100000000' ]]; then echo "" echo "文件大小：$bb" echo "此文件大于100M，将采用分片上传" echo "" qshell rput &lt;bucket&gt; $ii $1 | tee -a test1111 xx=$(cat test1111 | grep "Put" | awk -F ')' '&#123;print $2&#125;') rm test1111 if [[ $xx = ' success!' ]]; then echo "" echo "访问链接：" echo "http://&lt;domain&gt;/$ii" echo "" else echo "Fail, please try again!" fielse echo "File error~ 卧槽日了狗"fi 测试截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fhello-world.html</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 m3u8]]></title>
      <url>%2Fm3u8.html</url>
      <content type="text"><![CDATA[关于 m3u8M3U8是Unicode版本的M3U，用UTF-8编码。”M3U”和”M3U8”文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。m3u8 其实是一个文本文件，是一个 playlist，用来索引 ts 文件，真正的流媒体文件其实是ts 文件⭐️参考 wiki (https://zh.wikipedia.org/wiki/M3U#M3U8) 举个例子：http://sc.sc.bz1.me/123123123.m3u8 1234567891011121314#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:NO#EXT-X-TARGETDURATION:10#EXT-X-MEDIA-SEQUENCE:1#EXT-X-DISCONTINUITY#EXTINF:5.133,/fragments/z1.Newhub.5784a9645e77b0372002e792/1468570587846-1468570592979.ts#EXTINF:5.333,/fragments/z1.Newhub.5784a9645e77b0372002e792/1468570592238-1468570597571.ts#EXTINF:5.334,/fragments/z1.Newhub.5784a9645e77b0372002e792/1468570597278-1468570602612.ts&lt;此处省略部分&gt;#EXT-X-ENDLIST 七牛的avthumb 切片或者直播的转码服务，生成的 m3u8 文件格式大体如上，有的 m3u8 文件可能是在文本中是 http://domain/key.ts 的格式。 标准的 m3u8 文件遵循了 apple 公司的官方标准，可以用官方工具( mediastreamvalidator )检测看下，此处不赘述。1$ mediastreamvalidator http://sc.sc.bz1.me/123123123.m3u8 有一些可能就不是很标准，本文脚本可以拆分出每个 ts 的物理时间戳，走北京时间，并且计算出每个 ts 的时长和视频总时长，简单实用。实用脚本前需要先在本地下载七牛的 qshell 工具(http://developer.qiniu.com/code/v6/tool/qshell.html)，并且加入环境变量(全局可以运行 qshell) 脚本如下：1234567891011121314curl $1 | grep ts | awk -F '/z1.' '&#123;print $2&#125;' | awk -F '/' '&#123;print $2&#125;' | awk -F "." '&#123;print $1&#125;' | awk -F '-' '&#123;"qshell tms2d "$1|getline a; close("qshell tms2d "$1);"qshell tms2d "$2|getline b;close("qshell tms2d "$2);print a," ",b;&#125;' &gt;test11curl $1 | grep ts | awk -F '/z1.' '&#123;print $2&#125;' | awk -F '/' '&#123;print $2&#125;' | awk -F "." '&#123;print $1&#125;' | awk -F "-" '&#123;print ($2 - $1)/1000 " s"&#125;' &gt;test22cat test22 | awk '&#123;sum+=$1&#125; END &#123;print "Total = ", sum&#125;' &gt;test33paste test11 test22echo ""echo "m3u8中的ts文件总时长(分钟为单位)"cat test33 | awk '&#123;print $3/60 " min"&#125;'rm test11rm test22rm test33 测试输出如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PortSentry 保护云主机禁止被恶意扫描]]></title>
      <url>%2Fportsentry.html</url>
      <content type="text"><![CDATA[注：本文采用的操作系统为 ubuntu14.04 简介PortSentry is part of SentryTools. This daemon will watch unused ports for activity and depending on how it is configured take action upon excessive access to watched ports.wiki portsentry 采取的措施： 将流量引到一个虚假的路由，一个不存在的主机 自动对服务器端口扫描的主机加到 /etc/hosts.deny 文件中去 利用 Netfiliter 机制，用包过滤的机制，例如 iptables 和 ipchain 等，把非法的数据包（来自对主机进行端口扫描的主机）都过滤掉； 通过 syslog() 函数给出一个日志消息，或者一段警告信息 portsentry 安装下载地址 1http://sourceforge.net/projects/sentrytools/ 解压 1tar zxvf portsentry-1.2.tar.gz 不能直接编译，这里有点特殊，解压完的包中，portsentry.c这个文件中在1584行有一处错误，将其改成一行 1printf ("Copyright 1997-2003 Craig H. Rowland &lt;craigrowland at users dot sourceforget dot net&gt;\n"); 然后进行编译 1make linux&amp; make install 成功安装，安装的路劲为/usr/local/psionic/portsentry portsentry 配置修改配置文件 portsentry.conf通过 portsentry 进行入侵检测，如下段落为需要监视的端口清单，和相应的阻止措施。启动之后，后开进程开启监控这些端口，发现有人扫描，就启动相应的对策进行阻拦。 NO.1 Port Configurations这一端列出了默认的监视的端口，可以通过去掉#号来执行默认的配置，可以自行修改 12345678910111213# Port Configurations # Un-comment these if you are really anal:#TCP_PORTS="1,7,9,11,15,70,79,80,109,110,111,119,138,139,143,512,513,514,515,540,635,1080,1524,2000,2001,4000,4001,5742,6000,6001,6667,12345,12346,20034,27665,30303,32771,32772,32773,32774,31337,40421,40425,49724,54320"#UDP_PORTS="1,7,9,66,67,68,69,111,137,138,161,162,474,513,517,518,635,640,641,666,700,2049,31335,27444,34555,32770,32771,32772,32773,32774,31337,54321"## Use these if you just want to be aware:TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40421,49724,54320,51010"UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"## Use these for just bare-bones#TCP_PORTS="1,11,15,110,111,143,540,635,1080,1524,2000,12345,12346,20034,32771,32772,32773,32774,49724,54320"#UDP_PORTS="1,7,9,69,161,162,513,640,700,32770,32771,32772,32773,32774,31337,54321" NO.2 Advanced Stealth Scan Detection Options 12345678# Advanced Stealth Scan Detection OptionsADVANCED_PORTS_TCP="1024"ADVANCED_PORTS_UDP="1024"# Default TCP ident and NetBIOS serviceADVANCED_EXCLUDE_TCP="113,139"# Default UDP route (RIP), NetBIOS, bootp broadcasts.ADVANCED_EXCLUDE_UDP="520,138,137,67" NO.3 Configuration Files；portsentry.conf 相关的配置文件 12345678910# Configuration Files# Hosts to ignore #（ 此文件记录允许合法扫描服务的主机地址 ）IGNORE_FILE="/usr/local/psionic/portsentry/portsentry.ignore"# Hosts that have been denied (running history) #（ 此文件中保留入侵主机的 IP 地址 ）HISTORY_FILE="/usr/local/psionic/portsentry/portsentry.history"# Hosts that have been denied this session only (temporary until next restart)# （ 此文件中是已经被阻止连接的主机 IP 记录 ）BLOCKED_FILE="/usr/local/psionic/portsentry/portsentry.blocked" NO.4 Dropping Routes丢弃规则，也就是路由重定向，设置一条虚拟的路由记录，把数据包重定向到一个不存在的主机根据不同的操作系统，选择不同的命令 12345678910111213141516171819202122232425262728# Dropping Routes# Generic#KILL_ROUTE="/sbin/route add $TARGET$ 333.444.555.666"# Generic LinuxKILL_ROUTE="/sbin/route add -host $TARGET$ gw 333.444.555.666"# Newer versions of Linux support the reject flag now. This# is cleaner than the above option.#KILL_ROUTE="/sbin/route add -host $TARGET$ reject"# Generic BSD (BSDI, OpenBSD, NetBSD, FreeBSD)#KILL_ROUTE="/sbin/route add $TARGET$ 333.444.555.666"# Generic Sun#KILL_ROUTE="/usr/sbin/route add $TARGET$ 333.444.555.666 1"# NEXTSTEP#KILL_ROUTE="/usr/etc/route add $TARGET$ 127.0.0.1 1"# FreeBSD#KILL_ROUTE="route add -net $TARGET$ -netmask 255.255.255.255 127.0.0.1 -blackhole"# Digital UNIX 4.0D (OSF/1 / Compaq Tru64 UNIX)#KILL_ROUTE="/sbin/route add -host -blackhole $TARGET$ 127.0.0.1"# Generic HP-UX#KILL_ROUTE="/usr/sbin/route add net $TARGET$ netmask 255.255.255.0 127.0.0.1" NO.5 根据配置文件记录下的 IP，使用 iptables 阻塞掉，切断与其连接 1234567891011121314151617181920212223242526272829### Using a packet filter is the PREFERRED. The below lines# work well on many OS's. Remember, you can only uncomment *one*# KILL_ROUTE option.# ipfwadm support for Linux#KILL_ROUTE="/sbin/ipfwadm -I -i deny -S $TARGET$ -o"## ipfwadm support for Linux (no logging of denied packets)#KILL_ROUTE="/sbin/ipfwadm -I -i deny -S $TARGET$"## ipchain support for Linux#KILL_ROUTE="/sbin/ipchains -I input -s $TARGET$ -j DENY -l"## ipchain support for Linux (no logging of denied packets)#KILL_ROUTE="/sbin/ipchains -I input -s $TARGET$ -j DENY"## iptables support for Linux#KILL_ROUTE="/usr/local/bin/iptables -I INPUT -s $TARGET$ -j DROP"## For those of you running FreeBSD (and compatible) you can# use their built in firewalling as well.##KILL_ROUTE="/sbin/ipfw add 1 deny all from $TARGET$:255.255.255.255 to any"## For those running ipfilt (OpenBSD, etc.)# NOTE THAT YOU NEED TO CHANGE external_interface TO A VALID INTERFACE!!##KILL_ROUTE="/bin/echo 'block in log on external_interface from $TARGET$/32 to any' | /sbin/ipf -f -" NO.6 也可以把攻击者的 IP 记录到 /etc/hosts.deny 中，利用 TCP_Wrappers 机制防止被攻击 TCP_Wrappers ：Transmission Control Protocol (TCP) Wrappers 为由 inetd 生成的服务提供了增强的安全性。TCP Wrappers 是一种对使用 /etc/inetd.sec 的替换方法。TCP Wrappers 提供防止主机名和主机地址欺骗的保护。欺骗是一种伪装成有效用户或主机以获得对系统进行未经授权的访问的方法。 123# TCP Wrappers#KILL_HOSTS_DENY="ALL: $TARGET$" NO.7 定制警告信息，警告攻击者 12345678910# Port Banner Section### Enter text in here you want displayed to a person tripping the PortSentry.# I *don't* recommend taunting the person as this will aggravate them.# Leave this commented out to disable the feature## Stealth scan detection modes don't use this feature#PORT_BANNER="** UNAUTHORIZED ACCESS PROHIBITED *** YOUR CONNECTION ATTEMPT HAS BEEN LOGGED. GO AWAY." 修改 portsentry.ignore 的配置文件文件 /usr/local/psionic/portsentry/portsentry.ignore 配置上本地的 IP 和 常建立连接的主机，允许合法扫描 配置好之后最好修改一下 /usr/local/psionic/portsentry/portsentry.conf 和 /usr/local/psionic/portsentry/portsentry.ignore 的权限 12chmod 600 /usr/local/psionic/portsentry/portsentry.confchmod 600 /usr/local/psionic/portsentry/portsentry.ignore 开启监测模式PortSentry的启动检测模式。对应TCP和UDF两种协议方式，PortSentry分别有三种启动模式，即基本、秘密和高级秘密扫描检测模式，合计6个模式。 portsentry-tcp，TCP的基本端口绑定模式； portsentry-udp，UDP的基本端口绑定模式； portsentry-stcp，TCP的秘密扫描检测模式； portsentry-sudp，UDP的秘密扫描检测模式； portsentry-atcp，TCP的高级秘密扫描检测模式； portsentry-audp，UDP的高级秘密扫描检测模式。 一般情况下，建议使用秘密扫描检测模式或高级秘密扫描检测模式。使用高级秘密扫描检测模式（Advanced Stealth Scan Detection Mode），PortSentry会自动检查服务器上正在运行的端口， 然后把这些端口从配置文件中移去， 只监控其它的端口。这样会加快对端口扫描的反应速度，并且只占用很少的CPU时间，这种模式非常智能 启动命令： 1/usr/local/psionic/portsentry/portsentry -atcp 建议将这条命令写入 /etc/rc.local 中，这样开机就自启动了 测试我的云主机 A IP 假设为 XXX.XXX.XXX.XXX，云主机 A 上配置并开启了 portsentry开启一台云主机 B，IP 地址为 115.231.183.78 使用 云主机 B 扫描 云主机 A 的端口 云主机 A 监测到了恶意扫描，会将其加入 /etc/hosts.deny,并且在 /usr/local/psionic/portsentry/portsentry.blocked.atcp 会记录 block 掉了 简单处理一下，发现还有不是自己扫的，无聊的人也是多- -！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现 socks5 转换为 http 代理科学上网 (shadowsocks + polipo + pac)]]></title>
      <url>%2Fss-polipo-pac.html</url>
      <content type="text"><![CDATA[本文将从代理教会大家如何科学上网，作为笔记分享，共同学习，一起进步。 涉及如下三大块内容： shadowsocks（国外+国内） polipo pac 服务端安装 shadowsocksubuntu 14.041.由于 shadowsocks 是基于 Python 开发的，所以需要先安装 Python 1sudo apt-get update 2.安装 Python 的包管理器 pip 1sudo apt-get install python-pip 3.pip 安装好之后，直接安装 shadowsocks 1sudo pip install shadowsocks 配置 shadowsocks在 /etc/ 下新建一个文件 shadowsocks.json 12345678910&#123; "server":"0.0.0.0", #服务器 ip（ the ip your server listens ） "server_port":&lt;端口号1&gt;, #客户端连接端口，本地侦听 "local_address": "127.0.0.1", #本地代理地址( the address your local listen ) "local_port":&lt;端口号2&gt;, #自己设定的端口号( local port 127.0.0.1) "password":"&lt;password&gt;", #客户端连接密码 "timeout":300, #超时时间 "method":"aes-256-cfb", #加密方式 "fast_open": false #是否使用 tcp&#125; 注意：上述的 shadowsocks.json 是在国外的主机上进行的配置 服务端启动 shadowsocks（两种方式）12345第一种sudo ssserver -c /etc/shadowsocks.json -d start第二种sudo ssserver -s &lt;Server_ip&gt; -p &lt;端口号1&gt; -k &lt;password&gt; -m &lt;method&gt; -d start 配置开机自启动1234sudo vim /etc/rc.local添加一条sudo ssserver -c /etc/shadowsocks.json -d start 停止1sudo ssserver -c shadowsocks.json -d stop 检查日志1sudo less /var/log/shadowsocks.log 客户端安装 shadowsocks安装方法同服务端，配置有点区别这里是 shadowsocks.json 的配置： 12345678910&#123; "server":"&lt;Server_ip&gt;", #连接国外服务器的 ip "server_port":&lt;端口号1&gt;, #连接国外服务器的端口 "local_address":"0.0.0.0", #表示侦听来自所有 ip 的请求 "local_port":&lt;端口号3&gt;, #socks5侦听的端口（polipo 中 socksParentProxy） "password":"&lt;key&gt;", #连接服务器的密码 "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 客户端启动 shadowsocks（两种方法）12345第一种sudo sslocal -c /etc/shadowsocks.json -d restart第二种sudo sslocal -s &lt;Server_ip&gt; -p &lt;端口号1&gt; -k &lt;password&gt; -m &lt;method&gt; -b 0.0.0.0 -l &lt;端口号3&gt; -d start 这样执行以后这台主机就会连接到国外的主机，并开始侦听&lt;端口号3&gt;的 socks5代理了 配置开机自启动1234sudo vim /etc/rc.local添加一条sudo sslocal -c /etc/shadowsocks.json -d restart 停止1sudo sslocal -c /etc/shadowsocks.json -d stop 至此，shadowsocks 的配置就结束了。 polipo polipo 简介)Polipo 是一个小而快速的缓存 web 代理程序(web 缓存, HTTP 代理, 代理服务器)，可以将 socks5代理转换为 http 代理 安装 polipoubuntu 14.04 1sudo apt-get install polipo 配置文件/etc/polipo/config在配置文件中新增如下内容 123456logSyslog = true logFile = /var/log/polipo/polipo.log #日志proxyAddress = "0.0.0.0" #监听地址，四个0表示匹配所有proxyPort = &lt;端口号4&gt; #http 监听端口（同 PAC 配置文件）socksParentProxy = "127.0.0.1:&lt;端口号3&gt;" #指定 `socksProxyType` 的一级代理socksProxyType = socks5 #代理类型为 `socks5` 启动 polipo1sudo service polipo start 配置开机自启动1234sudo vim /etc/rc.local添加一条sudo service polipo start 至此，polipo 的配置完毕，并且可以本地测试一下是否已经代理到了国外主机 测试方法：浏览器设置socks5代理(ip为国内服务器，端口为本地侦听的端口3)确认是否通过ss翻墙 附录PAC 文件类似绑定 host 去访问国外的网站，通过FindProxyForURL(url, host)这个函数去实现。参数 url：网站 or 链接参数 host：对应的主机名 举例：1function FindProxyForURL(url, host) &#123; return "PROXY proxy.example.com:&lt;端口4&gt;; DIRECT"; &#125; 指定所有通过所有的流量都通过proxy.example.com的端口4代理出去 下载：点击下载 配置：PAC文件需要可以被访问，建议放在七牛或者阿里OSS这样的云存储上 假如是七牛，可以参考七牛的官方文档进行上传和访问 生成的模板如下：http://domain/a.pac 配置在 MAC 上打开系统偏好设置，选择网络 选择高级 选择代理，选择自动代理设置，URL 处填写 PAC 文件的访问地址 配置在 IOS 手机上打开设置==&gt;无线局域网，点击箭头所指位置 在最下面的 HTTP 代理中选择自动 此时，MAC 和 IOS 都可以科学上网啦~~~ 更多方式进行代理请参考 关于PAC自动代理和ios翻墙]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛直播域名图解]]></title>
      <url>%2Flivedomain.html</url>
      <content type="text"><![CDATA[七牛直播域名如图所示： rtmp推流域名 rtmp播放域名 hls播放域名 flv播放域名 所对应地址及其组成格式 开通七牛云直播，欢迎访问：http://www.qiniu.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置CDN加速域名时CNAME与A记录冲突原因及解决方式]]></title>
      <url>%2F%E5%9F%9F%E5%90%8Da%E8%AE%B0%E5%BD%95%E5%92%8Ccname%E5%86%B2%E7%AA%81.html</url>
      <content type="text"><![CDATA[问题描述假如用户的主页为www.xxx.com，为了使用CDN加速，在七牛也绑定了加速域名为www.xxx.com，绑定好了之后，七牛返回给用户一个CNAME的地址，此时用户去域名提供商那边去配置CNAME，然后提示 “CNAME记录与主机记录的A记录冲突，无法保存成功” 问题原因A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。这两个都是将您的当前域名（www.xxx.com）去解析到一个IP或者一个服务器，当访问您当前域名的时候会解析过去，但是一个域名不可以解析到两个服务器。 规避方式本文提供两种方式来解决既想使用CDN加速，又想使用www的域名。 方式一：直接使用CDN加速，不使用对象存储1.在七牛绑定了www.xxx.com的域名2.源站配置中选择IP地址，并且提供一下源站可访问的一个文件名（通过http:///文件名 可访问），然后点击测试，测试通过变为绿色字样即可。3.等候七牛处理完毕，并返回CNAME地址4.到域名提供上那边进行CNAME配置完毕，www.xxx.com开启了CDN加速 方式二：使用七牛镜像存储1.删除您域名提供商那边主机记录为www的A记录和CNAME2.配置test.xxx.com，配置A记录主机记录www，记录值为您的服务器IP3.在七牛绑定www.xxx.com的域名4.源站配置中选择七牛云存储，选定一个bucket，选择创建5.等候七牛处理完毕，并返回CNAME地址6.到域名提供上那边进行CNAME7.进入对应的bucket，选择镜像存储8.镜像源填写您的源站域名 test.xxx.com配置完毕，通过www.xxx.com便可访问您的源站（服务器）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RTMP可以播放，但是HLS不可以播放]]></title>
      <url>%2Fhlscannotplay.html</url>
      <content type="text"><![CDATA[问题描述：在七牛云开通了直播服务，创建了直播空间，也进行了CNAME，在使用七牛的提供的rtmp推流地址推流时，在拉流播放时候，发现RTMP播放域名可以播放，但是HLS却无法播放。 问题原因：这样的报错原因基本为以下三种之一原因一：检查一下推流地址是否填写的是RTMP的播放地址，导致RTMP可以正常播放，但是HLS不能，后台也查不到有推流上来。 原因二：编码原因，当用户推送的流不是h264 + acc/mp3 的视频 + 音频编码格式的时候，rtmp/hdl可能会可以播放，但是hls播放不了因为不是h264 + acc/mp3 的话，不会触发切片，即没有ts文件生成，所以hls 和回放点播都用不了可以调用 ffplay来播放 rtmp/hdl 来观看视频的编码格式 原因三：查看一下media域名的CNAME配置，看下是否配置错误或者没有配置。切片服务有问题。 原因四：crossdomain.xml 缺失在直播对应空间里面 原因五： ts文件对应域名没有取消302跳转 解决方法：一：使用该地址进行推流。 二：对视频进行转码，转成h264 + acc/mp3 的视频 + 音频编码格式然后再推，转码接口参考：http://developer.qiniu.com/code/v6/api/dora-api/av/avthumb.html 三：dig一下media的域名CNAME，检查到该域名是否进行了正确的CNAME。 12345~ » dig +short pili-media.live.bz1.me 1000117.media.z1.pili.qiniudns.com.wsall.qiniu.hls.wscdns.com.qiniu.livevideo.ourwebat.com.118.212.138.191 四：上传该crossdomain.xml 放入直播空间 点我下载 五：提交工单提供一下media的域名，取消302]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置CDN的资源访问流程]]></title>
      <url>%2FCDN%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86.html</url>
      <content type="text"><![CDATA[12345678910111213用户 1 CDN 源站 |—-----------&gt;| | |&lt;------------| | |—-----------&gt;| | | | 2 | | |—-----------&gt;| | 3 |&lt;------------| |&lt;------------| | | | | | 4 | | |—-----------&gt;| | |&lt;------------| | | 5 | | 1:用户第一次请求数据，与边缘CDN节点建立连接2:CDN回源站请求资源，源站响应，资源被拉取到CDN节点3:CDN将数据返回给用户，同时缓存在用户边缘CDN节点4:用户再次请求数据5:CDN服务器直接返回缓存在服务器上的数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛直播云常见FAQ]]></title>
      <url>%2Fpili%E7%9B%B4%E6%92%ADFAQ.html</url>
      <content type="text"><![CDATA[pili直播FAQ–功能 直播卡顿：如何排查直播卡顿问题？当用户提问这种的时候，一般如果不是已知事故，或已知异常。首先需要排除用户自身的网络原因，需要用户提供： a. 用户观看卡顿的播放地址 。 一个播放地址有很多信息，包括域名、hub、流名，使用hub，可以登录 pili-admin.qiniu.com ，通过hub找到该用户，然后进入到该用户的portal平台后，通过流名找到对应的流信息，通过域名可以判断用户播放域名的线路配置。如果在后台看到推流的码率和帧数信息就起伏不断，可以断定是推流端卡顿。这样就先不用去查播放端，先让用户确认推流端网络情况，并测试上行带宽 b. 如果用户推流端正常，需要询问播放端哪里卡，并让用户提供ping播放域名的结果，并提供本地IP和DNS，以及测试上行带宽的数据。 如果用户网络正常，得到用户ping到的节点IP后，最好可以自行绑定hosts到节点上观看看下效果。带宽测速工具：http://www.speed.netIP和DNS检测工具：http://ping.huatuo.qq.com/ 你们推流地址支持几种鉴权模式？可以详细介绍一下吗？ publishKey详谈 a.静态推流地址： 1rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt;?key=&lt;publishKey&gt; b.动态推流地址： 1234567rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt;?nonce=&lt;ANY_TIME_STAMP&gt;&amp;token=&lt;token&gt;``` 动态推流地址，需要签算nonce和token推流地址格式: ``` rtmp://&lt;HubDomain&gt;/&lt;HubName&gt;/&lt;StreamTitle&gt;?nonce=&lt;Nonce&gt;&amp;token=&lt;PublishToken&gt; token计算方法为： 12sign:= hmac_sha1("/&lt;HubName&gt;/&lt;StreamTitle&gt;?nonce=&lt;Nonce&gt;&amp;&lt;OtherKey&gt;=&lt;OtherValue&gt;", "&lt;PublishKey&gt;")publishToken := url_base64(sign) Nonce有效值为比上次推流使用的Nonce大的任意值。 c.关于publishKey，每个流都有自己的publishKey，静态地址是publishKey 加载URl后面就可以；动态是需要publishKey签算token，token加载URL后面。同时每个hub也绑了一个publishKey。如果你创建流的时候，没指定流的publishKey，那么流的publishKey是随机生成的一串字符串。create stream 和 update stream 方法可以为一个流来专门指定一个流的publishKey d. 如果hub的publishKey已知且推流地址使用的是该publishKey，那么如下推流地址中，title可以在推流的时候任意枚举（即不需要先create stream即可直接推流） 12rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt;?key=&lt;publishKey&gt;rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt;?nonce=&lt;ANY_TIME_STAMP&gt;&amp;token=&lt;token&gt; e. 存在另外一种鉴权，为expire，跟dynamic类似。expiry 限时推流地址，首先客户估计一个推流持续有效的时间（推荐为当前时间+30s），然后使用该时间签算token。 publishUrl是 1234567 rtmp://&lt;HubDomain&gt;/&lt;HubName&gt;/&lt;StreamTitle&gt;?expire=&lt;ExpireAt&gt;&amp;token=&lt;PublishToken&gt; ``` ExpireAt为unixstamp，单位为秒。服务器会以服务器时间为准，在此时刻之前，允许推流。超过这个时刻，拒绝推流。 token计算方法为： ``` sign := hmac_sha1("/&lt;HubName&gt;/&lt;StreamTitle&gt;?expire=&lt;ExpireAt&gt;&amp;&lt;OtherKey&gt;=&lt;OtherValue&gt;", "&lt;PublishKey&gt;") publishToken := url_base64(sign) f.手机端会自动根据json来生成好推流地址，如果是我们的推流SDK，无需担心，只需要传入json即可。 我的推流软件不允许我输入带?问号的推流地址，请问我该怎么办？ 关于hub配成none鉴权登录pili-admin，找到对应用户，点击左侧对应的Uid，跳转后，获得页面内的Access Token。设置none鉴权： 123456curl "http://pili.qiniuapi.com/v1/hubs/&lt;YOUR_HUB_NAME&gt;" -H "Authorization: Bearer &lt;Access_None&gt;" -d '&#123;"publishSecurity":"none"&#125;'``` none鉴权的hub推流方式：``` rtmp://&lt;push_domain&gt;/&lt;hub&gt;/&lt;title&gt; title可以不要createstream而容易枚举 当前直播域名原生配置：| 加速类型 | 加速域名 | 回源域名 | 回源协议 | 特别说明 | 参照域名 || ——- | ——————– | ——————————— | —- | —— | ——— || 直播 M3U8 | live-hls.example.com | src.live-hls.z1.pili.qiniudns.com | http | No 302 | qiniu.hls || 直播 M3U8 | playback.example.com | src.playback.z1.pili.qiniudns.com | http | No 302 | qiniu.hls || 直播 TS | media.example.com | src.media.z1.pili.qiniudns.com | http | No 302 | qiniu.hls || 图片 IMG | static.example.com | src.static.z1.pili.qiniudns.com | http | | qiniu.dn | 主动推流： RTMP推流域名：.pushcdn-ws.z1.pili.qiniup.com (ws为网宿缩写，可能是其他CDN厂商，后续再说)RTMP播放域名：live-rtmp.example.comHDL 播放域名: live-hdl.example.comindex 进入到用户portal后点域名绑定，能看到cname值的第一个 字符+数字级，即是index值 为什么我推流结束了，流还持续了一段时间connect状态？timeout机制当一个流正在推的时候，stream.status 可以获取到流的状态为 connected， 当pili持续30秒内没有收到推流端推送来的数据后，流会由connected变为disconnected30秒即为该hub的timeout，30秒的值可以 在用户portal中的应用属性中设置。实际是：用户发数据包到pili的streamgate，streamgate 在发到 Zoned。zoned在30秒内没有收到数据即会将流置为disconnected。由于一次数据可能会延时到10秒才会发送，所以不建议timeout太小。 流状态变化没有回调？流状态回调，用户portal的应用属性可以设置流状态回调url，即用户提供一个URL，然后填入。之后该hub容易流 如果有 disconnect 和connect动作都会触发回调，服务端会调用如下接口回调用户的业务服务器：1234567891011POST /user/callback/endpointX-PILI-MD5: &lt;DataSign&gt;&#123; "message": "streamStatus", "updatedAt": "&lt;UpdatedAt&gt;", "data": &#123; "id": "&lt;StreamID&gt;", "url": "&lt;PublishUrl&gt;", "status": "&lt;StreamStatus&gt;" &#125;&#125; 2xx // 通知成功4xx 5xx // 通知失败，之后重试一次，重试后再不成功，放弃通知DataSign 算法：sign := md5(request.Body) // 原始16字符二进制格式, 而非32字符十六进制数DataSign := urlsafe_base64_encode(sign)PHP:\$dataSign = strreplace(array(‘+’, ‘/‘), array(‘-‘, ‘‘), base64_encode(md5($reqBody, true)));Go:hash := md5.New()hash.Write([]byte(request.Body))dataSign := base64.URLEncoding.EncodeToString(hash.Sum(nil))登录跳板机，qlogview，根据流id 过滤BC目录下的 APP_ZONED日志，可以过滤历史回调记录 注：目前如果在推流过程中调用stream.disabled，streamgate会中断与zoned的任何通信， Zoned是不会将流置为disconnect，且不会触发回调，除非streamgate再与zoned通信，例如用户再触发推流的操作 实时截图功能是干什么用的?自动抽帧，可以在portal的应用空间开启，开启后，可以选择生成的图片的名字key的规则当没有设置notifyUrl 和 pipeline的时候，实际调用的是vframe的即时抽帧。抽帧的图片存在直播绑定的空间内。通过 http:/// 就可以访问截图是每个切片产生后就会生成调用一次vframe 直播如何实现鉴黄（版本：不得不做 1.0）？① 登录 https://portal.qiniu.com（新版） 新建一个对象存储空间bucket② 进入到这个对象存储空间内，点击页面上方的更多操作，选择 “镜像存储”, 在镜像源这一行 填入 绑定域名③ 第二步的”绑定域名” 从哪来？ ，登录 https://pili.qiniu.com , 进入hub后， 点击“应用属性” ， 复制里面的 “截图访问域名” 下对应的域名，填入到第二步里面的 “镜像存储” 中 需要填入的域名④ 通过 https://pili.qiniu.com 里面的实时截图，或者 stream.snapshot(）后，得到截图的链接，假设链接是 http://pili-img.example.com/hub/test.jpg⑤ 返回https://portal.qiniu.com， 这个对象存储空间内 ，在域名设置中随便使用一个域名，替换掉 pili-img.example.com⑥ get请求 http://替换后的域名/hub/test.jpg?nrop ， 返回的结果详情查看：http://developer.qiniu.com/code/v6/api/dora-api/third-party/nrop.html pili直播FAQ–服务端 我调用saveas有问题，请问如何可以回播？关于回放另存为 a. 建议用户使用stream.saveas ,stream.playbackUrls 方法已经打算废弃，部分SDK已经实现stream.playbackUrls 内嵌 stream.saveas()。 b. 如果stream.saveas 的 format参数传空值，那么会即时返回m3u8回放地址； 如果format 参数传 非 空值，那么会调用 fop 的avthumb进行转码；（这就需要客户考虑pipeline和notifyUrl等参数了） c. 转码失败情况，可能失败原因：① 传空值失败， 该流没有推流 或 id有误 或 saveas指定 的start 和end 时间段内没有ts内容② 传非空值失败，已经调用过，且第二次调用重名③ 传非空失败，推流分为很多次，且每次推流参数（譬如码率，分辨率，帧数）变化很大 SDK 是否支持水印、数据预处理?iOS 实现两个办法：使用 PLStreamingKit, https://github.com/pili-engineering/PLStreamingKit 这个 SDK，数据采集都有开发者自己来做；使用 PLCameraStreamingKit，使用 PLCameraStreamingSession 的下面这个回调：/// @abstract 获取到摄像头原数据时的回调, 便于开发者做滤镜、水印等处理(CMSampleBufferRef)cameraStreamingSession:(PLCameraStreamingSession *)session cameraSourceDidGetSampleBuffer:(CMSampleBufferRef)sampleBuffer;PLStreamingKit 与 PLCameraStreamingKit 的差别现在 iOS 推流 SDK 分为 PLStreamingKit 与 PLCameraStreamingKit, 关系和差别：PLStreamingKit 只处理音视频编码和推流PLCameraStreamingKit 依赖 PLStreamingKitPLCameraStreamingKit 比 PLStreamingKit 多了摄像头和麦克风数据采集并且采集部分开源PLCameraStreamingKit 对接比较快，但是不适合做采集部分处理（比如滤镜、降噪等）有采集定制需求推荐用 PLStreamingKit，可以更快的做出需求调整 安卓实现现在仅支持软编版本。数据分为两路，一路用来做显示，一路用来做编码。显示：请实现 SurfaceTextureCallback 该数据源为 SurfaceTexture 的纹理 ID。编码：请实现 StreamingPreviewCallback 该数据源为 NV21 类型的 YUV 数据，你只需要处理 onPreviewFrame 中的 datas 数据即可。详细信息请查看 README 。具体的水印、滤镜效果，需要客户自己实现。 弹幕，字幕，聊天如何在直播里实现?这属于业务需求，Pili 目前没有实现这样的接口最简单的实现方式是浮动一个透明的窗口，上面把字幕信息显示在上面，目前也有很不错的开源解决方案，比如：聊天服务器可以使用 leancloud 的 实时通信服务总览(https://leancloud.cn/docs/realtime_v2.html)弹幕可以使用 Bilibili/DanmakuFlameMaster(https://github.com/Bilibili/DanmakuFlameMaster) pili直播FAQ–客户端 为什么我rtmp 和 hdl可以播放， hls不能?a.当用户推送的流不是h264 + acc/mp3 的视频 + 音频编码格式的时候，rtmp/hdl可能会可以播放，但是hls播放不了因为不是h264 + acc/mp3 的话，不会触发切片，即没有ts文件生成，所以hls 和 回放点播都用不了可以调用 ffplay来播放 rtmp/hdl 来观看视频的编码格式b.检查hls域名以及ts文件的media域名的配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim]]></title>
      <url>%2Fvim.html</url>
      <content type="text"><![CDATA[vim的学习笔记，这些是vim常用的一些操作按键。 光标移动 查找与替换 删除、复制与粘贴 其他 光标移动1234567891011121314151617n&lt;space&gt;：n代表数字，按下光标再按空格键，光标会移动到这一行的n个字符0：移动到这一行第一个字符$：移动到这一行的最后一个字符H：移动到屏幕最上方那行L：移动到屏幕最下方那行G：移动到这个文件最后一行nG：移动到n行gg：移动到文件第一行n&lt;Enter&gt;：向下移动n行 查找与替换1234567/word：查找word:n1,n2s/word1/word2/g：n1到n2行之间查找word1，全部替换为word2:1,$s/word1/word2/g：从第一行到最后一行查找word1，全部替换为word2:1,$s/word1/word2/gc：从第一行到最后一行查找word1，全部替换为word2，替换前确认 删除、复制和粘贴12345678910111213x：向后删一个字符X：向前删一个字符dd：删除一整行ndd：向下删除n行yy：复制光标所在那一行p：复制的数据在光标下一行粘贴P：复制的数据在光标上一行粘贴 其他12345u：复原前一个动作:!command：暂时命令行模式执行command:set nu：显示行号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cloudcomputing]]></title>
      <url>%2Fcloudcomputing.html</url>
      <content type="text"><![CDATA[李开复（现任 Google 全球副总裁、中国区总裁）打了一个很形象的比喻：钱庄。最早人们只是把钱放在枕头底下，后来有了钱庄，很安全，不过兑现起来比较麻烦。现在发展到银行可以到任何一个网点取钱，甚至通过 ATM，或者国外的渠道。就像用电不需要家家装备发电机，直接从电力公司购买一样。“云计算”带来的就是这样一种变革——由谷歌、IBM 这样的专业网络公司来搭建计算机存储、运算中心，用户通过一根网线借助浏览器就可以很方便的访问，把“云”做为资料存储以及应用服务的中心。 GOOGLE（一）原理: 云计算(Cloud Computing)是分布式处理(Distributed Computing)、并行处理(Parallel Comput、ing)和网格计算(Grid Computing)的发展，或者说是这些计算机科学概念的商业实现。云计算的基本原理是，通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将更与互联网相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。这可是一种革命性的举措，打个比方，这就好比是从古老的单台发电机模式转向了电厂集中供电的模式。它意味着计算能力也可以作为一种商品进行流通，就像煤气、水电一样，取用方便，费用低廉。最大的不同在于，它是通过互联网进行传输的。 云计算的蓝图已经呼之欲出：在未来，只需要一台笔记本或者一个手机，就可以通过网络服务来实现我们需要的一切，甚至包括超级计算这样的任务。从这个角度而言，最终用户才是云计算的真正拥有者。 云计算的应用包含这样的一种思想，把力量联合起来，给其中的每一个成员使用。 （二）云计算有哪些好处？ 1、安全，云计算提供了最可靠、最安全的数据存储中心，用户不用再担心数据丢失、病毒入侵等麻烦。 2、方便，它对用户端的设备要求最低，使用起来很方便。 3、数据共享，它可以轻松实现不同设备间的数据与应用共享。 4、无限可能，它为我们使用网络提供了几乎无限多的可能。 （三）云计算最有利于中小企业？云计算技术将使得中小企业的成本大大降低。如果说“云”给大型企业的 IT 部门带来了实惠，那么对于中小型企业而言，它可算得上是上天的恩赐了。过去，小公司人力资源不足，IT 预算吃紧，那种动辄数百万美元的 IT 设备所带来的生产力对它们而言真是如梦一般遥远，而如今，“云”为它们送来了大企业级的技术，并且先期成本极低，升级也很方便。这一新兴趋势的重要性毋庸置疑，不过，它还仅仅是一系列变革的起步阶段而已。云计算不但抹平了企业规模所导致的优劣差距，而且极有可能让优劣之势易主。简单地说，当今世上最强大最具革新意义的技术已不再为大型企业所独有。“云”让每个普通人都能以极低的成本接触到顶尖的 IT技术。 （四）“云”时代目前，PC 依然是我们日常工作生活中的核心工具——我们用 PC 处理文档、存储资料，通过电子邮件或 U 盘与他人分享信息。如果 PC 硬盘坏了，我们会因为资料丢失而束手无策。而在“云计算”时代，“云”会替我们做存储和计算的工作。“云”就是计算机群，每一群包括了几十万台、甚至上百万台计算机。“云”的好处还在于，其中的计算机可以随时更新，保证“云”长生不老。Google 就有好几个这样的“云”，其他 IT 巨头，如微软、雅虎、亚马逊（Amazon）也有或正在建设这样的“云”。届时，我们只需要一台能上网的电脑，不需关心存储或计算发生在哪朵“云”上，但一旦有需要，我们可以在任何地点用任何设备，如电脑、手机等，快速地计算和找到这些资料。我们再也不用担心资料丢失。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos6.5-配置yum安装nginx]]></title>
      <url>%2Fnginx-centos6-5-yum.html</url>
      <content type="text"><![CDATA[在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo： 123cd /etc/yum.repos.d/ vim nginx.repo 填写如下内容： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 wq以后会产生一个文件为：/etc/yum.repos.d/nginx.repo 下面直接执行如下指令即可自动安装好Nginx： 1yum install nginx -y 安装完成，下面直接就可以启动Nginx了： 1/etc/init.d/nginx start 现在Nginx已经启动了，直接访问服务器就能看到Nginx欢迎页面了的。 如果还无法访问，则需配置一下Linux防火墙 12345iptables -I INPUT 5 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT service iptables save service iptables restart Nginx的命令以及配置文件位置： 12345/etc/init.d/nginx start # 启动Nginx服务 /etc/init.d/nginx stop # 停止Nginx服务 /etc/nginx/nginx.conf # Nginx配置文件位置 至此，Nginx已经全部配置安装完成。]]></content>
    </entry>

    
  
  
</search>
